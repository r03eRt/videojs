/*! @name videojs-playlist @version 4.2.3 @license Apache-2.0 */
(function (videojs,QUnit,sinon) {
	'use strict';

	videojs = videojs && videojs.hasOwnProperty('default') ? videojs['default'] : videojs;
	QUnit = QUnit && QUnit.hasOwnProperty('default') ? QUnit['default'] : QUnit;
	sinon = sinon && sinon.hasOwnProperty('default') ? sinon['default'] : sinon;

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var win;

	if (typeof window !== "undefined") {
	    win = window;
	} else if (typeof commonjsGlobal !== "undefined") {
	    win = commonjsGlobal;
	} else if (typeof self !== "undefined"){
	    win = self;
	} else {
	    win = {};
	}

	var window_1 = win;

	/**
	 * Validates a number of seconds to use as the auto-advance delay.
	 *
	 * @private
	 * @param   {number} s
	 *          The number to check
	 *
	 * @return  {boolean}
	 *          Whether this is a valid second or not
	 */
	var validSeconds = function validSeconds(s) {
	  return typeof s === 'number' && !isNaN(s) && s >= 0 && s < Infinity;
	};

	/**
	 * Resets the auto-advance behavior of a player.
	 *
	 * @param {Player} player
	 *        The player to reset the behavior on
	 */
	var reset = function reset(player) {
	  var aa = player.playlist.autoadvance_;

	  if (aa.timeout) {
	    player.clearTimeout(aa.timeout);
	  }

	  if (aa.trigger) {
	    player.off('ended', aa.trigger);
	  }

	  aa.timeout = null;
	  aa.trigger = null;
	};

	/**
	 * Sets up auto-advance behavior on a player.
	 *
	 * @param  {Player} player
	 *         the current player
	 *
	 * @param  {number} delay
	 *         The number of seconds to wait before each auto-advance.
	 *
	 * @return {undefined}
	 *         Used to short circuit function logic
	 */
	var setup = function setup(player, delay) {
	  reset(player);

	  // Before queuing up new auto-advance behavior, check if `seconds` was
	  // called with a valid value.
	  if (!validSeconds(delay)) {
	    player.playlist.autoadvance_.delay = null;
	    return;
	  }

	  player.playlist.autoadvance_.delay = delay;

	  player.playlist.autoadvance_.trigger = function () {

	    // This calls setup again, which will reset the existing auto-advance and
	    // set up another auto-advance for the next "ended" event.
	    var cancelOnPlay = function cancelOnPlay() {
	      return setup(player, delay);
	    };

	    // If there is a "play" event while we're waiting for an auto-advance,
	    // we need to cancel the auto-advance. This could mean the user seeked
	    // back into the content or restarted the content. This is reproducible
	    // with an auto-advance > 0.
	    player.one('play', cancelOnPlay);

	    player.playlist.autoadvance_.timeout = player.setTimeout(function () {
	      reset(player);
	      player.off('play', cancelOnPlay);
	      player.playlist.next();
	    }, delay * 1000);
	  };

	  player.one('ended', player.playlist.autoadvance_.trigger);
	};

	/**
	 * Used to change the reset function in this module at runtime
	 * This should only be used in tests.
	 *
	 * @param {Function} fn
	 *        The function to se the reset to
	 */
	var setReset_ = function setReset_(fn) {
	  reset = fn;
	};

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	var proxy = function proxy(props) {
	  var player = _extends({}, videojs.EventTarget.prototype, {
	    play: function play() {},
	    paused: function paused() {},
	    ended: function ended() {},
	    poster: function poster() {},
	    src: function src() {},
	    currentSrc: function currentSrc() {},
	    addRemoteTextTrack: function addRemoteTextTrack() {},
	    removeRemoteTextTrack: function removeRemoteTextTrack() {},
	    remoteTextTracks: function remoteTextTracks() {},
	    playlist: {
	      autoadvance_: {},
	      currentIndex_: -1,
	      autoadvance: function autoadvance() {},
	      contains: function contains() {},
	      currentItem: function currentItem() {},
	      first: function first() {},
	      indexOf: function indexOf() {},
	      next: function next() {},
	      previous: function previous() {}
	    },
	    ready: function ready(cb) {
	      return cb();
	    },
	    setTimeout: function setTimeout(cb, wait) {
	      return window_1.setTimeout(cb, wait);
	    },
	    clearTimeout: function clearTimeout(id) {
	      return window_1.clearTimeout(id);
	    }
	  }, props);

	  player.constructor = videojs.getComponent('Player');
	  player.playlist.player_ = player;

	  return player;
	};

	QUnit.module('auto-advance');

	QUnit.test('set up ended listener if one does not exist yet', function (assert) {
	  var player = proxy();
	  var ones = [];

	  player.one = function (type) {
	    ones.push(type);
	  };

	  setup(player, 0);

	  assert.equal(ones.length, 1, 'there should have been only one one event added');
	  assert.equal(ones[0], 'ended', 'the event we want to one is "ended"');
	});

	QUnit.test('off previous listener if exists before adding a new one', function (assert) {
	  var player = proxy();
	  var ones = [];
	  var offs = [];

	  player.one = function (type) {
	    ones.push(type);
	  };

	  player.off = function (type) {
	    offs.push(type);
	  };

	  setup(player, 0);
	  assert.equal(ones.length, 1, 'there should have been only one one event added');
	  assert.equal(ones[0], 'ended', 'the event we want to one is "ended"');
	  assert.equal(offs.length, 0, 'we should not have off-ed anything yet');

	  setup(player, 10);

	  assert.equal(ones.length, 2, 'there should have been only two one event added');
	  assert.equal(ones[0], 'ended', 'the event we want to one is "ended"');
	  assert.equal(ones[1], 'ended', 'the event we want to one is "ended"');
	  assert.equal(offs.length, 1, 'there should have been only one off event added');
	  assert.equal(offs[0], 'ended', 'the event we want to off is "ended"');
	});

	QUnit.test('do nothing if timeout is weird', function (assert) {
	  var player = proxy();

	  var ones = [];
	  var offs = [];

	  player.one = function (type) {
	    ones.push(type);
	  };

	  player.off = function (type) {
	    offs.push(type);
	  };

	  setup(player, -1);
	  setup(player, -100);
	  setup(player, null);
	  setup(player, {});
	  setup(player, []);

	  assert.equal(offs.length, 0, 'we did nothing');
	  assert.equal(ones.length, 0, 'we did nothing');
	});

	QUnit.test('reset if timeout is weird after we advance', function (assert) {
	  var player = proxy();

	  var ones = [];
	  var offs = [];

	  player.one = function (type) {
	    ones.push(type);
	  };

	  player.off = function (type) {
	    offs.push(type);
	  };

	  setup(player, 0);
	  setup(player, -1);
	  setup(player, 0);
	  setup(player, -100);
	  setup(player, 0);
	  setup(player, null);
	  setup(player, 0);
	  setup(player, {});
	  setup(player, 0);
	  setup(player, []);
	  setup(player, 0);
	  setup(player, NaN);
	  setup(player, 0);
	  setup(player, Infinity);
	  setup(player, 0);
	  setup(player, -Infinity);

	  assert.equal(offs.length, 8, 'we reset the advance 8 times');
	  assert.equal(ones.length, 8, 'we autoadvanced 8 times');
	});

	QUnit.test('reset if we have already started advancing', function (assert) {
	  var player = proxy();
	  var oldClearTimeout = window_1.clearTimeout;
	  var clears = 0;

	  window_1.clearTimeout = function () {
	    clears++;
	  };

	  // pretend we started autoadvancing
	  player.playlist.autoadvance_.timeout = 1;
	  setup(player, 0);

	  assert.equal(clears, 1, 'we reset the auto advance');

	  window_1.clearTimeout = oldClearTimeout;
	});

	QUnit.test('timeout is given in seconds', function (assert) {
	  var player = proxy();
	  var oldSetTimeout = window_1.setTimeout;

	  player.addEventListener = Function.prototype;

	  window_1.setTimeout = function (fn, timeout) {
	    assert.equal(timeout, 10 * 1000, 'timeout was given in seconds');
	  };

	  setup(player, 10);
	  player.trigger('ended');

	  window_1.setTimeout = oldSetTimeout;
	});

	QUnit.test('cancel a pending auto-advance if play is requested', function (assert) {
	  var clock = sinon.useFakeTimers();
	  var player = proxy();

	  sinon.spy(player.playlist, 'next');

	  setup(player, 10);
	  player.trigger('ended');
	  clock.tick(10000);

	  assert.equal(player.playlist.next.callCount, 1, 'next was called');

	  setup(player, 10);
	  player.trigger('ended');
	  clock.tick(5000);
	  player.trigger('play');
	  clock.tick(5000);

	  assert.equal(player.playlist.next.callCount, 1, 'next was not called because a "play" occurred');

	  player.trigger('ended');
	  clock.tick(10000);

	  assert.equal(player.playlist.next.callCount, 2, 'next was called again because the content ended again and the appropriate wait time elapsed');
	});

	/**
	 * Removes all remote text tracks from a player.
	 *
	 * @param  {Player} player
	 *         The player to clear tracks on
	 */
	var clearTracks = function clearTracks(player) {
	  var tracks = player.remoteTextTracks();
	  var i = tracks && tracks.length || 0;

	  // This uses a `while` loop rather than `forEach` because the
	  // `TextTrackList` object is a live DOM list (not an array).
	  while (i--) {
	    player.removeRemoteTextTrack(tracks[i]);
	  }
	};

	/**
	 * Plays an item on a player's playlist.
	 *
	 * @param  {Player} player
	 *         The player to play the item on
	 *
	 * @param  {Object} item
	 *         A source from the playlist.
	 *
	 * @return {Player}
	 *         The player that is now playing the item
	 */
	var playItem = function playItem(player, item) {
	  var replay = !player.paused() || player.ended();

	  player.trigger('beforeplaylistitem', item);
	  player.poster(item.poster || '');
	  player.src(item.sources);
	  clearTracks(player);

	  player.ready(function () {
	    (item.textTracks || []).forEach(player.addRemoteTextTrack.bind(player));
	    player.trigger('playlistitem', item);

	    if (replay) {
	      var playPromise = player.play();

	      // silence error when a pause interrupts a play request
	      // on browsers which return a promise
	      if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {
	        playPromise.then(null, function (e) {});
	      }
	    }

	    setup(player, player.playlist.autoadvance_.delay);
	  });

	  return player;
	};

	QUnit.module('play-item');

	QUnit.test('clearTracks will try and remove all tracks', function (assert) {
	  var player = proxy();
	  var remoteTracks = [1, 2, 3];
	  var removedTracks = [];

	  player.remoteTextTracks = function () {
	    return remoteTracks;
	  };

	  player.removeRemoteTextTrack = function (tt) {
	    removedTracks.push(tt);
	  };

	  clearTracks(player);

	  assert.deepEqual(removedTracks.sort(), remoteTracks.sort(), 'the removed tracks are equivalent to our remote tracks');
	});

	QUnit.test('will not try to play if paused', function (assert) {
	  var player = proxy();
	  var tryPlay = false;

	  player.paused = function () {
	    return true;
	  };

	  player.play = function () {
	    tryPlay = true;
	  };

	  playItem(player, {
	    sources: [1, 2, 3],
	    textTracks: [4, 5, 6],
	    poster: 'http://example.com/poster.png'
	  });

	  assert.ok(!tryPlay, 'we did not reply on paused');
	});

	QUnit.test('will try to play if not paused', function (assert) {
	  var player = proxy();
	  var tryPlay = false;

	  player.paused = function () {
	    return false;
	  };

	  player.play = function () {
	    tryPlay = true;
	  };

	  playItem(player, {
	    sources: [1, 2, 3],
	    textTracks: [4, 5, 6],
	    poster: 'http://example.com/poster.png'
	  });

	  assert.ok(tryPlay, 'we replayed on not-paused');
	});

	QUnit.test('will not try to play if paused and not ended', function (assert) {
	  var player = proxy();
	  var tryPlay = false;

	  player.paused = function () {
	    return true;
	  };

	  player.ended = function () {
	    return false;
	  };

	  player.play = function () {
	    tryPlay = true;
	  };

	  playItem(player, {
	    sources: [1, 2, 3],
	    textTracks: [4, 5, 6],
	    poster: 'http://example.com/poster.png'
	  });

	  assert.ok(!tryPlay, 'we did not replaye on paused and not ended');
	});

	QUnit.test('will try to play if paused and ended', function (assert) {
	  var player = proxy();
	  var tryPlay = false;

	  player.paused = function () {
	    return true;
	  };

	  player.ended = function () {
	    return true;
	  };

	  player.play = function () {
	    tryPlay = true;
	  };

	  playItem(player, {
	    sources: [1, 2, 3],
	    poster: 'http://example.com/poster.png'
	  });

	  assert.ok(tryPlay, 'we replayed on not-paused');
	});

	QUnit.test('fires "beforeplaylistitem" and "playlistitem"', function (assert) {
	  var player = proxy();
	  var beforeSpy = sinon.spy();
	  var spy = sinon.spy();

	  player.on('beforeplaylistitem', beforeSpy);
	  player.on('playlistitem', spy);

	  playItem(player, {
	    sources: [1, 2, 3],
	    poster: 'http://example.com/poster.png'
	  });

	  assert.strictEqual(beforeSpy.callCount, 1);
	  assert.strictEqual(spy.callCount, 1);
	});

	/**
	 * Given two sources, check to see whether the two sources are equal.
	 * If both source urls have a protocol, the protocols must match, otherwise, protocols
	 * are ignored.
	 *
	 * @private
	 * @param {string|Object} source1
	 *        The first source
	 *
	 * @param {string|Object} source2
	 *        The second source
	 *
	 * @return {boolean}
	 *         The result
	 */
	var sourceEquals = function sourceEquals(source1, source2) {
	  var src1 = source1;
	  var src2 = source2;

	  if ((typeof source1 === 'undefined' ? 'undefined' : _typeof(source1)) === 'object') {
	    src1 = source1.src;
	  }
	  if ((typeof source2 === 'undefined' ? 'undefined' : _typeof(source2)) === 'object') {
	    src2 = source2.src;
	  }

	  if (/^\/\//.test(src1)) {
	    src2 = src2.slice(src2.indexOf('//'));
	  }
	  if (/^\/\//.test(src2)) {
	    src1 = src1.slice(src1.indexOf('//'));
	  }

	  return src1 === src2;
	};

	/**
	 * Look through an array of playlist items for a specific `source`;
	 * checking both the value of elements and the value of their `src`
	 * property.
	 *
	 * @private
	 * @param   {Array} arr
	 *          An array of playlist items to look through
	 *
	 * @param   {string} src
	 *          The source to look for
	 *
	 * @return  {number}
	 *          The index of that source or -1
	 */
	var indexInSources = function indexInSources(arr, src) {
	  for (var i = 0; i < arr.length; i++) {
	    var sources = arr[i].sources;

	    if (Array.isArray(sources)) {
	      for (var j = 0; j < sources.length; j++) {
	        var source = sources[j];

	        if (source && sourceEquals(source, src)) {
	          return i;
	        }
	      }
	    }
	  }

	  return -1;
	};

	/**
	 * Randomize the contents of an array.
	 *
	 * @private
	 * @param  {Array} arr
	 *         An array.
	 *
	 * @return {Array}
	 *         The same array that was passed in.
	 */
	var randomize = function randomize(arr) {
	  var index = -1;
	  var lastIndex = arr.length - 1;

	  while (++index < arr.length) {
	    var rand = index + Math.floor(Math.random() * (lastIndex - index + 1));
	    var value = arr[rand];

	    arr[rand] = arr[index];
	    arr[index] = value;
	  }

	  return arr;
	};

	/**
	 * Factory function for creating new playlist implementation on the given player.
	 *
	 * API summary:
	 *
	 * playlist(['a', 'b', 'c']) // setter
	 * playlist() // getter
	 * playlist.currentItem() // getter, 0
	 * playlist.currentItem(1) // setter, 1
	 * playlist.next() // 'c'
	 * playlist.previous() // 'b'
	 * playlist.first() // 'a'
	 * playlist.last() // 'c'
	 * playlist.autoadvance(5) // 5 second delay
	 * playlist.autoadvance() // cancel autoadvance
	 *
	 * @param  {Player} player
	 *         The current player
	 *
	 * @param  {Array=} initialList
	 *         If given, an initial list of sources with which to populate
	 *         the playlist.
	 *
	 * @param  {number=}  initialIndex
	 *         If given, the index of the item in the list that should
	 *         be loaded first. If -1, no video is loaded. If omitted, The
	 *         the first video is loaded.
	 *
	 * @return {Function}
	 *         Returns the playlist function specific to the given player.
	 */
	function factory(player, initialList) {
	  var initialIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	  var list = null;
	  var changing = false;

	  /**
	   * Get/set the playlist for a player.
	   *
	   * This function is added as an own property of the player and has its
	   * own methods which can be called to manipulate the internal state.
	   *
	   * @param  {Array} [newList]
	   *         If given, a new list of sources with which to populate the
	   *         playlist. Without this, the function acts as a getter.
	   *
	   * @param  {number}  [newIndex]
	   *         If given, the index of the item in the list that should
	   *         be loaded first. If -1, no video is loaded. If omitted, The
	   *         the first video is loaded.
	   *
	   * @return {Array}
	   *         The playlist
	   */
	  var playlist = player.playlist = function (newList) {
	    var newIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    if (changing) {
	      throw new Error('do not call playlist() during a playlist change');
	    }

	    if (Array.isArray(newList)) {

	      // @todo - Simplify this to `list.slice()` for v5.
	      var previousPlaylist = Array.isArray(list) ? list.slice() : null;

	      list = newList.slice();

	      // Mark the playlist as changing during the duringplaylistchange lifecycle.
	      changing = true;

	      player.trigger({
	        type: 'duringplaylistchange',
	        nextIndex: newIndex,
	        nextPlaylist: list,
	        previousIndex: playlist.currentIndex_,

	        // @todo - Simplify this to simply pass along `previousPlaylist` for v5.
	        previousPlaylist: previousPlaylist || []
	      });

	      changing = false;

	      if (newIndex !== -1) {
	        playlist.currentItem(newIndex);
	      }

	      // The only time the previous playlist is null is the first call to this
	      // function. This allows us to fire the `duringplaylistchange` event
	      // every time the playlist is populated and to maintain backward
	      // compatibility by not firing the `playlistchange` event on the initial
	      // population of the list.
	      //
	      // @todo - Remove this condition in preparation for v5.
	      if (previousPlaylist) {
	        player.setTimeout(function () {
	          player.trigger('playlistchange');
	        }, 0);
	      }
	    }

	    // Always return a shallow clone of the playlist list.
	    return list.slice();
	  };

	  // On a new source, if there is no current item, disable auto-advance.
	  player.on('loadstart', function () {
	    if (playlist.currentItem() === -1) {
	      reset(player);
	    }
	  });

	  playlist.currentIndex_ = -1;
	  playlist.player_ = player;
	  playlist.autoadvance_ = {};
	  playlist.repeat_ = false;

	  /**
	   * Get or set the current item in the playlist.
	   *
	   * During the duringplaylistchange event, acts only as a getter.
	   *
	   * @param  {number} [index]
	   *         If given as a valid value, plays the playlist item at that index.
	   *
	   * @return {number}
	   *         The current item index.
	   */
	  playlist.currentItem = function (index) {

	    // If the playlist is changing, only act as a getter.
	    if (changing) {
	      return playlist.currentIndex_;
	    }

	    if (typeof index === 'number' && playlist.currentIndex_ !== index && index >= 0 && index < list.length) {
	      playlist.currentIndex_ = index;
	      playItem(playlist.player_, list[playlist.currentIndex_]);
	    } else {
	      playlist.currentIndex_ = playlist.indexOf(playlist.player_.currentSrc() || '');
	    }

	    return playlist.currentIndex_;
	  };

	  /**
	   * Checks if the playlist contains a value.
	   *
	   * @param  {string|Object|Array} value
	   *         The value to check
	   *
	   * @return {boolean}
	   *         The result
	   */
	  playlist.contains = function (value) {
	    return playlist.indexOf(value) !== -1;
	  };

	  /**
	   * Gets the index of a value in the playlist or -1 if not found.
	   *
	   * @param  {string|Object|Array} value
	   *         The value to find the index of
	   *
	   * @return {number}
	   *         The index or -1
	   */
	  playlist.indexOf = function (value) {
	    if (typeof value === 'string') {
	      return indexInSources(list, value);
	    }

	    var sources = Array.isArray(value) ? value : value.sources;

	    for (var i = 0; i < sources.length; i++) {
	      var source = sources[i];

	      if (typeof source === 'string') {
	        return indexInSources(list, source);
	      } else if (source.src) {
	        return indexInSources(list, source.src);
	      }
	    }

	    return -1;
	  };

	  /**
	   * Get the index of the current item in the playlist. This is identical to
	   * calling `currentItem()` with no arguments.
	   *
	   * @return {number}
	   *         The current item index.
	   */
	  playlist.currentIndex = function () {
	    return playlist.currentItem();
	  };

	  /**
	   * Get the index of the last item in the playlist.
	   *
	   * @return {number}
	   *         The index of the last item in the playlist or -1 if there are no
	   *         items.
	   */
	  playlist.lastIndex = function () {
	    return list.length - 1;
	  };

	  /**
	   * Get the index of the next item in the playlist.
	   *
	   * @return {number}
	   *         The index of the next item in the playlist or -1 if there is no
	   *         current item.
	   */
	  playlist.nextIndex = function () {
	    var current = playlist.currentItem();

	    if (current === -1) {
	      return -1;
	    }

	    var lastIndex = playlist.lastIndex();

	    // When repeating, loop back to the beginning on the last item.
	    if (playlist.repeat_ && current === lastIndex) {
	      return 0;
	    }

	    // Don't go past the end of the playlist.
	    return Math.min(current + 1, lastIndex);
	  };

	  /**
	   * Get the index of the previous item in the playlist.
	   *
	   * @return {number}
	   *         The index of the previous item in the playlist or -1 if there is
	   *         no current item.
	   */
	  playlist.previousIndex = function () {
	    var current = playlist.currentItem();

	    if (current === -1) {
	      return -1;
	    }

	    // When repeating, loop back to the end of the playlist.
	    if (playlist.repeat_ && current === 0) {
	      return playlist.lastIndex();
	    }

	    // Don't go past the beginning of the playlist.
	    return Math.max(current - 1, 0);
	  };

	  /**
	   * Plays the first item in the playlist.
	   *
	   * @return {Object|undefined}
	   *         Returns undefined and has no side effects if the list is empty.
	   */
	  playlist.first = function () {
	    if (changing) {
	      return;
	    }

	    if (list.length) {
	      return list[playlist.currentItem(0)];
	    }

	    playlist.currentIndex_ = -1;
	  };

	  /**
	   * Plays the last item in the playlist.
	   *
	   * @return {Object|undefined}
	   *         Returns undefined and has no side effects if the list is empty.
	   */
	  playlist.last = function () {
	    if (changing) {
	      return;
	    }

	    if (list.length) {
	      return list[playlist.currentItem(playlist.lastIndex())];
	    }

	    playlist.currentIndex_ = -1;
	  };

	  /**
	   * Plays the next item in the playlist.
	   *
	   * @return {Object|undefined}
	   *         Returns undefined and has no side effects if on last item.
	   */
	  playlist.next = function () {
	    if (changing) {
	      return;
	    }

	    var index = playlist.nextIndex();

	    if (index !== playlist.currentIndex_) {
	      return list[playlist.currentItem(index)];
	    }
	  };

	  /**
	   * Plays the previous item in the playlist.
	   *
	   * @return {Object|undefined}
	   *         Returns undefined and has no side effects if on first item.
	   */
	  playlist.previous = function () {
	    if (changing) {
	      return;
	    }

	    var index = playlist.previousIndex();

	    if (index !== playlist.currentIndex_) {
	      return list[playlist.currentItem(index)];
	    }
	  };

	  /**
	   * Set up auto-advance on the playlist.
	   *
	   * @param  {number} [delay]
	   *         The number of seconds to wait before each auto-advance.
	   */
	  playlist.autoadvance = function (delay) {
	    setup(playlist.player_, delay);
	  };

	  /**
	   * Sets `repeat` option, which makes the "next" video of the last video in
	   * the playlist be the first video in the playlist.
	   *
	   * @param  {boolean} [val]
	   *         The value to set repeat to
	   *
	   * @return {boolean}
	   *         The current value of repeat
	   */
	  playlist.repeat = function (val) {
	    if (val === undefined) {
	      return playlist.repeat_;
	    }

	    if (typeof val !== 'boolean') {
	      videojs.log.error('videojs-playlist: Invalid value for repeat', val);
	      return;
	    }

	    playlist.repeat_ = !!val;
	    return playlist.repeat_;
	  };

	  /**
	   * Sorts the playlist array.
	   *
	   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}
	   * @fires playlistsorted
	   *
	   * @param {Function} compare
	   *        A comparator function as per the native Array method.
	   */
	  playlist.sort = function (compare) {

	    // Bail if the array is empty.
	    if (!list.length) {
	      return;
	    }

	    list.sort(compare);

	    // If the playlist is changing, don't trigger events.
	    if (changing) {
	      return;
	    }

	    /**
	     * Triggered after the playlist is sorted internally.
	     *
	     * @event playlistsorted
	     * @type {Object}
	     */
	    player.trigger('playlistsorted');
	  };

	  /**
	   * Reverses the playlist array.
	   *
	   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}
	   * @fires playlistsorted
	   */
	  playlist.reverse = function () {

	    // Bail if the array is empty.
	    if (!list.length) {
	      return;
	    }

	    list.reverse();

	    // If the playlist is changing, don't trigger events.
	    if (changing) {
	      return;
	    }

	    /**
	     * Triggered after the playlist is sorted internally.
	     *
	     * @event playlistsorted
	     * @type {Object}
	     */
	    player.trigger('playlistsorted');
	  };

	  /**
	   * Shuffle the contents of the list randomly.
	   *
	   * @see   {@link https://github.com/lodash/lodash/blob/40e096b6d5291a025e365a0f4c010d9a0efb9a69/shuffle.js}
	   * @fires playlistsorted
	   * @todo  Make the `rest` option default to `true` in v5.0.0.
	   * @param {Object} [options]
	   *        An object containing shuffle options.
	   *
	   * @param {boolean} [options.rest = false]
	   *        By default, the entire playlist is randomized. However, this may
	   *        not be desirable in all cases, such as when a user is already
	   *        watching a video.
	   *
	   *        When `true` is passed for this option, it will only shuffle
	   *        playlist items after the current item. For example, when on the
	   *        first item, will shuffle the second item and beyond.
	   */
	  playlist.shuffle = function () {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        rest = _ref.rest;

	    var index = 0;
	    var arr = list;

	    // When options.rest is true, start randomization at the item after the
	    // current item.
	    if (rest) {
	      index = playlist.currentIndex_ + 1;
	      arr = list.slice(index);
	    }

	    // Bail if the array is empty or too short to shuffle.
	    if (arr.length <= 1) {
	      return;
	    }

	    randomize(arr);

	    // When options.rest is true, splice the randomized sub-array back into
	    // the original array.
	    if (rest) {
	      var _list;

	      (_list = list).splice.apply(_list, [index, arr.length].concat(arr));
	    }

	    // If the playlist is changing, don't trigger events.
	    if (changing) {
	      return;
	    }

	    /**
	     * Triggered after the playlist is sorted internally.
	     *
	     * @event playlistsorted
	     * @type {Object}
	     */
	    player.trigger('playlistsorted');
	  };

	  // If an initial list was given, populate the playlist with it.
	  if (Array.isArray(initialList)) {
	    playlist(initialList.slice(), initialIndex);

	    // If there is no initial list given, silently set an empty array.
	  } else {
	    list = [];
	  }

	  return playlist;
	}

	var videoList = [{
	  sources: [{
	    src: 'http://media.w3.org/2010/05/sintel/trailer.mp4',
	    type: 'video/mp4'
	  }],
	  poster: 'http://media.w3.org/2010/05/sintel/poster.png'
	}, {
	  sources: [{
	    src: 'http://media.w3.org/2010/05/bunny/trailer.mp4',
	    type: 'video/mp4'
	  }],
	  poster: 'http://media.w3.org/2010/05/bunny/poster.png'
	}, {
	  sources: [{
	    src: 'http://vjs.zencdn.net/v/oceans.mp4',
	    type: 'video/mp4'
	  }],
	  poster: 'http://www.videojs.com/img/poster.jpg'
	}, {
	  sources: [{
	    src: 'http://media.w3.org/2010/05/bunny/movie.mp4',
	    type: 'video/mp4'
	  }],
	  poster: 'http://media.w3.org/2010/05/bunny/poster.png'
	}, {
	  sources: [{
	    src: 'http://media.w3.org/2010/05/video/movie_300.mp4',
	    type: 'video/mp4'
	  }],
	  poster: 'http://media.w3.org/2010/05/video/poster.png'
	}];

	QUnit.module('playlist-maker', {
	  beforeEach: function beforeEach() {
	    this.clock = sinon.useFakeTimers();
	  },
	  afterEach: function afterEach() {
	    this.clock.restore();
	  }
	});

	QUnit.test('playlistMaker takes a player and a list and returns a playlist', function (assert) {
	  var playlist = factory(proxy(), []);

	  assert.equal(typeof playlist === 'undefined' ? 'undefined' : _typeof(playlist), 'function', 'playlist is a function');
	  assert.equal(_typeof(playlist.autoadvance), 'function', 'we have a autoadvance function');

	  assert.equal(_typeof(playlist.currentItem), 'function', 'we have a currentItem function');

	  assert.equal(_typeof(playlist.first), 'function', 'we have a first function');
	  assert.equal(_typeof(playlist.indexOf), 'function', 'we have a indexOf function');
	  assert.equal(_typeof(playlist.next), 'function', 'we have a next function');
	  assert.equal(_typeof(playlist.previous), 'function', 'we have a previous function');
	});

	QUnit.test('playlistMaker can either take nothing or an Array as its first argument', function (assert) {
	  var playlist1 = factory(proxy());
	  var playlist2 = factory(proxy(), 'foo');
	  var playlist3 = factory(proxy(), { foo: [1, 2, 3] });

	  assert.deepEqual(playlist1(), [], 'if given no initial array, default to an empty array');

	  assert.deepEqual(playlist2(), [], 'if given no initial array, default to an empty array');

	  assert.deepEqual(playlist3(), [], 'if given no initial array, default to an empty array');
	});

	QUnit.test('playlist() is a getter and setter for the list', function (assert) {
	  var playlist = factory(proxy(), [1, 2, 3]);

	  assert.deepEqual(playlist(), [1, 2, 3], 'equal to input list');

	  assert.deepEqual(playlist([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5], 'equal to input list, arguments ignored');

	  assert.deepEqual(playlist(), [1, 2, 3, 4, 5], 'equal to input list');

	  var list = playlist();

	  list.unshift(10);

	  assert.deepEqual(playlist(), [1, 2, 3, 4, 5], 'changing the list did not affect the playlist');

	  assert.notDeepEqual(playlist(), [10, 1, 2, 3, 4, 5], 'changing the list did not affect the playlist');
	});

	QUnit.test('playlist() should only accept an Array as a new playlist', function (assert) {
	  var playlist = factory(proxy(), [1, 2, 3]);

	  assert.deepEqual(playlist('foo'), [1, 2, 3], 'when given "foo", it should be treated as a getter');

	  assert.deepEqual(playlist({ foo: [1, 2, 3] }), [1, 2, 3], 'when given {foo: [1,2,3]}, it should be treated as a getter');
	});

	QUnit.test('playlist.currentItem() works as expected', function (assert) {
	  var player = proxy();
	  var playlist = factory(player, videoList);
	  var src = void 0;

	  player.src = function (s) {
	    if (s) {
	      if (typeof s === 'string') {
	        src = s;
	      } else if (Array.isArray(s)) {
	        return player.src(s[0]);
	      } else {
	        return player.src(s.src);
	      }
	    }
	  };

	  player.currentSrc = function () {
	    return src;
	  };

	  src = videoList[0].sources[0].src;

	  assert.equal(playlist.currentItem(), 0, 'begin at the first item, item 0');

	  assert.equal(playlist.currentItem(2), 2, 'setting to item 2 gives us back the new item index');

	  assert.equal(playlist.currentItem(), 2, 'the current item is now 2');
	  assert.equal(playlist.currentItem(5), 2, 'cannot change to an out-of-bounds item');
	  assert.equal(playlist.currentItem(-1), 2, 'cannot change to an out-of-bounds item');
	  assert.equal(playlist.currentItem(null), 2, 'cannot change to an invalid item');
	  assert.equal(playlist.currentItem(NaN), 2, 'cannot change to an invalid item');
	  assert.equal(playlist.currentItem(Infinity), 2, 'cannot change to an invalid item');
	  assert.equal(playlist.currentItem(-Infinity), 2, 'cannot change to an invalid item');
	});

	QUnit.test('playlist.currentItem() returns -1 with an empty playlist', function (assert) {
	  var playlist = factory(proxy(), []);

	  assert.equal(playlist.currentItem(), -1, 'we should get a -1 with an empty playlist');
	});

	QUnit.test('playlist.currentItem() does not change items if same index is given', function (assert) {
	  var player = proxy();
	  var sources = 0;
	  var src = void 0;

	  player.src = function (s) {
	    if (s) {
	      if (typeof s === 'string') {
	        src = s;
	      } else if (Array.isArray(s)) {
	        return player.src(s[0]);
	      } else {
	        return player.src(s.src);
	      }
	    }

	    sources++;
	  };

	  player.currentSrc = function () {
	    return src;
	  };

	  var playlist = factory(player, videoList);

	  assert.equal(sources, 1, 'we switched to the first playlist item');
	  sources = 0;

	  assert.equal(playlist.currentItem(), 0, 'we start at index 0');

	  playlist.currentItem(0);
	  assert.equal(sources, 0, 'we did not try to set sources');

	  playlist.currentItem(1);
	  assert.equal(sources, 1, 'we did try to set sources');

	  playlist.currentItem(1);
	  assert.equal(sources, 1, 'we did not try to set sources');
	});

	QUnit.test('playlistMaker accepts a starting index', function (assert) {
	  var player = proxy();
	  var src = void 0;

	  player.src = function (s) {
	    if (s) {
	      if (typeof s === 'string') {
	        src = s;
	      } else if (Array.isArray(s)) {
	        return player.src(s[0]);
	      } else {
	        return player.src(s.src);
	      }
	    }
	  };

	  player.currentSrc = function () {
	    return src;
	  };

	  var playlist = factory(player, videoList, 1);

	  assert.equal(playlist.currentItem(), 1, 'if given an initial index, load that video');
	});

	QUnit.test('playlistMaker accepts a starting index', function (assert) {
	  var player = proxy();
	  var src = void 0;

	  player.src = function (s) {
	    if (s) {
	      if (typeof s === 'string') {
	        src = s;
	      } else if (Array.isArray(s)) {
	        return player.src(s[0]);
	      } else {
	        return player.src(s.src);
	      }
	    }
	  };

	  player.currentSrc = function () {
	    return src;
	  };

	  var playlist = factory(player, videoList, -1);

	  assert.equal(playlist.currentItem(), -1, 'if given -1 as initial index, load no video');
	});

	QUnit.test('playlist.contains() works as expected', function (assert) {
	  var player = proxy();
	  var playlist = factory(player, videoList);

	  player.playlist = playlist;

	  assert.ok(playlist.contains('http://media.w3.org/2010/05/sintel/trailer.mp4'), 'we can ask whether it contains a source string');

	  assert.ok(playlist.contains(['http://media.w3.org/2010/05/sintel/trailer.mp4']), 'we can ask whether it contains a sources list of strings');

	  assert.ok(playlist.contains([{
	    src: 'http://media.w3.org/2010/05/sintel/trailer.mp4',
	    type: 'video/mp4'
	  }]), 'we can ask whether it contains a sources list of objects');

	  assert.ok(playlist.contains({
	    sources: ['http://media.w3.org/2010/05/sintel/trailer.mp4']
	  }), 'we can ask whether it contains a playlist item');

	  assert.ok(playlist.contains({
	    sources: [{
	      src: 'http://media.w3.org/2010/05/sintel/trailer.mp4',
	      type: 'video/mp4'
	    }]
	  }), 'we can ask whether it contains a playlist item');

	  assert.ok(!playlist.contains('http://media.w3.org/2010/05/sintel/poster.png'), 'we get false for a non-existent source string');

	  assert.ok(!playlist.contains(['http://media.w3.org/2010/05/sintel/poster.png']), 'we get false for a non-existent source list of strings');

	  assert.ok(!playlist.contains([{
	    src: 'http://media.w3.org/2010/05/sintel/poster.png',
	    type: 'video/mp4'
	  }]), 'we get false for a non-existent source list of objects');

	  assert.ok(!playlist.contains({
	    sources: ['http://media.w3.org/2010/05/sintel/poster.png']
	  }), 'we can ask whether it contains a playlist item');

	  assert.ok(!playlist.contains({
	    sources: [{
	      src: 'http://media.w3.org/2010/05/sintel/poster.png',
	      type: 'video/mp4'
	    }]
	  }), 'we get false for a non-existent playlist item');
	});

	QUnit.test('playlist.indexOf() works as expected', function (assert) {
	  var player = proxy();
	  var playlist = factory(player, videoList);

	  var mixedSourcesPlaylist = factory(player, [{
	    sources: [{
	      src: 'http://media.w3.org/2010/05/sintel/trailer.mp4',
	      type: 'video/mp4'
	    }, {
	      app_name: 'rtmp://example.com/sintel/trailer', // eslint-disable-line
	      avg_bitrate: 4255000, // eslint-disable-line
	      codec: 'H264',
	      container: 'MP4'
	    }],
	    poster: 'http://media.w3.org/2010/05/sintel/poster.png'
	  }]);

	  player.playlist = playlist;

	  assert.equal(playlist.indexOf('http://media.w3.org/2010/05/sintel/trailer.mp4'), 0, 'sintel trailer is first item');

	  assert.equal(playlist.indexOf('//media.w3.org/2010/05/sintel/trailer.mp4'), 0, 'sintel trailer is first item, protocol-relative url considered equal');

	  assert.equal(playlist.indexOf(['http://media.w3.org/2010/05/bunny/trailer.mp4']), 1, 'bunny trailer is second item');

	  assert.equal(playlist.indexOf([{
	    src: 'http://vjs.zencdn.net/v/oceans.mp4',
	    type: 'video/mp4'
	  }]), 2, 'oceans is third item');

	  assert.equal(playlist.indexOf({
	    sources: ['http://media.w3.org/2010/05/bunny/movie.mp4']
	  }), 3, 'bunny movie is fourth item');

	  assert.equal(playlist.indexOf({
	    sources: [{
	      src: 'http://media.w3.org/2010/05/video/movie_300.mp4',
	      type: 'video/mp4'
	    }]
	  }), 4, 'timer video is fifth item');

	  assert.equal(playlist.indexOf('http://media.w3.org/2010/05/sintel/poster.png'), -1, 'poster.png does not exist');

	  assert.equal(playlist.indexOf(['http://media.w3.org/2010/05/sintel/poster.png']), -1, 'poster.png does not exist');

	  assert.equal(playlist.indexOf([{
	    src: 'http://media.w3.org/2010/05/sintel/poster.png',
	    type: 'video/mp4'
	  }]), -1, 'poster.png does not exist');

	  assert.equal(playlist.indexOf({
	    sources: ['http://media.w3.org/2010/05/sintel/poster.png']
	  }), -1, 'poster.png does not exist');

	  assert.equal(playlist.indexOf({
	    sources: [{
	      src: 'http://media.w3.org/2010/05/sintel/poster.png',
	      type: 'video/mp4'
	    }]
	  }), -1, 'poster.png does not exist');

	  assert.equal(mixedSourcesPlaylist.indexOf({
	    sources: [{
	      src: 'http://media.w3.org/2010/05/bunny/movie.mp4',
	      type: 'video/mp4'
	    }, {
	      app_name: 'rtmp://example.com/bunny/movie', // eslint-disable-line
	      avg_bitrate: 4255000, // eslint-disable-line
	      codec: 'H264',
	      container: 'MP4'
	    }],
	    poster: 'http://media.w3.org/2010/05/sintel/poster.png'
	  }), -1, 'bunny movie does not exist');

	  assert.equal(mixedSourcesPlaylist.indexOf({
	    sources: [{
	      src: 'http://media.w3.org/2010/05/sintel/trailer.mp4',
	      type: 'video/mp4'
	    }, {
	      app_name: 'rtmp://example.com/sintel/trailer', // eslint-disable-line
	      avg_bitrate: 4255000, // eslint-disable-line
	      codec: 'H264',
	      container: 'MP4'
	    }],
	    poster: 'http://media.w3.org/2010/05/sintel/poster.png'
	  }), 0, 'sintel trailer does exist');
	});

	QUnit.test('playlist.nextIndex() works as expected', function (assert) {
	  var playlist = factory(proxy(), []);

	  assert.equal(playlist.nextIndex(), -1, 'the next index was -1 for an empty list');

	  playlist([1, 2, 3]);
	  playlist.currentItem = function () {
	    return 0;
	  };
	  assert.equal(playlist.nextIndex(), 1, 'the next index was 1');

	  playlist.currentItem = function () {
	    return 1;
	  };
	  assert.equal(playlist.nextIndex(), 2, 'the next index was 2');

	  playlist.currentItem = function () {
	    return 2;
	  };
	  assert.equal(playlist.nextIndex(), 2, 'the next index did not change because the playlist does not repeat');

	  playlist.repeat(true);
	  assert.equal(playlist.nextIndex(), 0, 'the next index was now 0 because the playlist repeats');
	});

	QUnit.test('playlist.previousIndex() works as expected', function (assert) {
	  var playlist = factory(proxy(), []);

	  assert.equal(playlist.previousIndex(), -1, 'the previous index was -1 for an empty list');

	  playlist([1, 2, 3]);
	  playlist.currentItem = function () {
	    return 2;
	  };
	  assert.equal(playlist.previousIndex(), 1, 'the previous index was 1');

	  playlist.currentItem = function () {
	    return 1;
	  };
	  assert.equal(playlist.previousIndex(), 0, 'the previous index was 0');

	  playlist.currentItem = function () {
	    return 0;
	  };
	  assert.equal(playlist.previousIndex(), 0, 'the previous index did not change because the playlist does not repeat');

	  playlist.repeat(true);
	  assert.equal(playlist.previousIndex(), 2, 'the previous index was now 2 because the playlist repeats');
	});

	QUnit.test('playlist.lastIndex() works as expected', function (assert) {
	  var playlist = factory(proxy(), []);

	  assert.equal(playlist.lastIndex(), -1, 'the last index was -1 for an empty list');

	  playlist([1, 2, 3]);
	  assert.equal(playlist.lastIndex(), 2, 'the last index was 2');
	});

	QUnit.test('playlist.next() works as expected', function (assert) {
	  var player = proxy();
	  var playlist = factory(player, videoList);
	  var src = void 0;

	  player.currentSrc = function () {
	    return src;
	  };

	  src = videoList[0].sources[0].src;
	  assert.equal(playlist.currentItem(), 0, 'we start on item 0');

	  assert.deepEqual(playlist.next(), videoList[1], 'we get back the value of currentItem 2');

	  src = videoList[1].sources[0].src;
	  assert.equal(playlist.currentItem(), 1, 'we are now on item 1');

	  assert.deepEqual(playlist.next(), videoList[2], 'we get back the value of currentItem 3');

	  src = videoList[2].sources[0].src;
	  assert.equal(playlist.currentItem(), 2, 'we are now on item 2');
	  src = videoList[4].sources[0].src;
	  assert.equal(playlist.currentItem(4), 4, 'we are now on item 4');

	  assert.equal(_typeof(playlist.next()), 'undefined', 'we get nothing back if we try to go out of bounds');
	});

	QUnit.test('playlist.previous() works as expected', function (assert) {
	  var player = proxy();
	  var playlist = factory(player, videoList);
	  var src = void 0;

	  player.currentSrc = function () {
	    return src;
	  };

	  src = videoList[0].sources[0].src;
	  assert.equal(playlist.currentItem(), 0, 'we start on item 0');

	  assert.equal(_typeof(playlist.previous()), 'undefined', 'we get nothing back if we try to go out of bounds');

	  src = videoList[2].sources[0].src;
	  assert.equal(playlist.currentItem(), 2, 'we are on item 2');

	  assert.deepEqual(playlist.previous(), videoList[1], 'we get back value of currentItem 1');

	  src = videoList[1].sources[0].src;
	  assert.equal(playlist.currentItem(), 1, 'we are on item 1');

	  assert.deepEqual(playlist.previous(), videoList[0], 'we get back value of currentItem 0');

	  src = videoList[0].sources[0].src;
	  assert.equal(playlist.currentItem(), 0, 'we are on item 0');

	  assert.equal(_typeof(playlist.previous()), 'undefined', 'we get nothing back if we try to go out of bounds');
	});

	QUnit.test('loading a non-playlist video will cancel autoadvance and set index of -1', function (assert) {
	  var oldReset = reset;
	  var player = proxy();

	  var playlist = factory(player, [{
	    sources: [{
	      src: 'http://media.w3.org/2010/05/sintel/trailer.mp4',
	      type: 'video/mp4'
	    }],
	    poster: 'http://media.w3.org/2010/05/sintel/poster.png'
	  }, {
	    sources: [{
	      src: 'http://media.w3.org/2010/05/bunny/trailer.mp4',
	      type: 'video/mp4'
	    }],
	    poster: 'http://media.w3.org/2010/05/bunny/poster.png'
	  }]);

	  player.currentSrc = function () {
	    return 'http://vjs.zencdn.net/v/oceans.mp4';
	  };

	  setReset_(function () {
	    assert.ok(true, 'autoadvance.reset was called');
	  });

	  player.trigger('loadstart');

	  assert.equal(playlist.currentItem(), -1, 'new currentItem is -1');

	  player.currentSrc = function () {
	    return 'http://media.w3.org/2010/05/sintel/trailer.mp4';
	  };

	  setReset_(function () {
	    assert.ok(false, 'autoadvance.reset should not be called');
	  });

	  player.trigger('loadstart');

	  setReset_(oldReset);
	});

	QUnit.test('when loading a new playlist, trigger "duringplaylistchange" on the player', function (assert) {
	  var done = assert.async();
	  var player = proxy();
	  var playlist = factory(player, [1, 2, 3], 1);

	  player.on('duringplaylistchange', function (e) {
	    assert.strictEqual(e.type, 'duringplaylistchange', 'the event object had the correct "type" property');
	    assert.strictEqual(e.previousIndex, 1, 'the event object had the correct "previousIndex" property');
	    assert.deepEqual(e.previousPlaylist, [1, 2, 3], 'the event object had the correct "previousPlaylist" property');
	    assert.strictEqual(e.nextIndex, 0, 'the event object had the correct "nextIndex" property');
	    assert.deepEqual(e.nextPlaylist, [4, 5, 6], 'the event object had the correct "nextPlaylist" property');

	    assert.throws(function () {
	      playlist([1, 2, 3]);
	    }, Error, 'cannot set a new playlist during a change');

	    var spy = sinon.spy();

	    player.on('playlistsorted', spy);
	    playlist.sort();
	    playlist.reverse();
	    playlist.shuffle();
	    assert.strictEqual(spy.callCount, 0, 'the "playlistsorted" event never fired');

	    playlist.currentItem(2);
	    assert.strictEqual(playlist.currentItem(), 1, 'the playlist current item could not be changed');

	    playlist.next();
	    assert.strictEqual(playlist.currentItem(), 1, 'the playlist current item could not be changed');

	    playlist.previous();
	    assert.strictEqual(playlist.currentItem(), 1, 'the playlist current item could not be changed');

	    playlist.first();
	    assert.strictEqual(playlist.currentItem(), 1, 'the playlist current item could not be changed');

	    playlist.last();
	    assert.strictEqual(playlist.currentItem(), 1, 'the playlist current item could not be changed');

	    done();
	  });

	  playlist([4, 5, 6]);
	});

	QUnit.test('when loading a new playlist, trigger "playlistchange" on the player', function (assert) {
	  var spy = sinon.spy();
	  var player = proxy();

	  player.on('playlistchange', spy);
	  var playlist = factory(player, [1, 2, 3]);

	  playlist([4, 5, 6]);
	  this.clock.tick(1);

	  assert.strictEqual(spy.callCount, 1);
	  assert.strictEqual(spy.firstCall.args[0].type, 'playlistchange');
	});

	QUnit.test('"duringplaylistchange" and "playlistchange" on first call without an initial list', function (assert) {
	  var changeSpy = sinon.spy();
	  var duringSpy = sinon.spy();
	  var player = proxy();

	  player.on('playlistchange', changeSpy);
	  player.on('duringplaylistchange', duringSpy);

	  var playlist = factory(player);

	  this.clock.tick(1);

	  assert.strictEqual(changeSpy.callCount, 0, 'on initial call, the "playlistchange" event did not fire');
	  assert.strictEqual(duringSpy.callCount, 0, 'on initial call, the "duringplaylistchange" event did not fire');

	  playlist([1]);
	  this.clock.tick(1);

	  assert.strictEqual(changeSpy.callCount, 1, 'on second call, the "playlistchange" event did fire');
	  assert.strictEqual(duringSpy.callCount, 1, 'on second call, the "duringplaylistchange" event did fire');

	  playlist([2]);
	  this.clock.tick(1);

	  assert.strictEqual(changeSpy.callCount, 2, 'on third call, the "playlistchange" event did fire');
	  assert.strictEqual(duringSpy.callCount, 2, 'on third call, the "duringplaylistchange" event did fire');
	});

	QUnit.test('"duringplaylistchange" and "playlistchange" on first call with an initial list', function (assert) {
	  var changeSpy = sinon.spy();
	  var duringSpy = sinon.spy();
	  var player = proxy();

	  player.on('playlistchange', changeSpy);
	  player.on('duringplaylistchange', duringSpy);

	  var playlist = factory(player, [1]);

	  this.clock.tick(1);

	  assert.strictEqual(changeSpy.callCount, 0, 'on initial call, the "playlistchange" event did not fire');
	  assert.strictEqual(duringSpy.callCount, 1, 'on initial call, the "duringplaylistchange" event did fire');

	  playlist([2]);
	  this.clock.tick(1);

	  assert.strictEqual(changeSpy.callCount, 1, 'on second call, the "playlistchange" event did fire');
	  assert.strictEqual(duringSpy.callCount, 2, 'on second call, the "duringplaylistchange" event did fire');

	  playlist([3]);
	  this.clock.tick(1);

	  assert.strictEqual(changeSpy.callCount, 2, 'on third call, the "playlistchange" event did fire');
	  assert.strictEqual(duringSpy.callCount, 3, 'on third call, the "duringplaylistchange" event did fire');
	});

	QUnit.test('playlist.sort() works as expected', function (assert) {
	  var player = proxy();
	  var spy = sinon.spy();

	  player.on('playlistsorted', spy);
	  var playlist = factory(player, []);

	  playlist.sort();
	  assert.deepEqual(playlist(), [], 'playlist did not change because it is empty');
	  assert.strictEqual(spy.callCount, 0, 'the "playlistsorted" event did not trigger');

	  playlist([4, 2, 1, 3]);

	  playlist.sort();
	  assert.deepEqual(playlist(), [1, 2, 3, 4], 'playlist is sorted per default sort behavior');
	  assert.strictEqual(spy.callCount, 1, 'the "playlistsorted" event triggered');

	  playlist.sort(function (a, b) {
	    return b - a;
	  });
	  assert.deepEqual(playlist(), [4, 3, 2, 1], 'playlist is sorted per default sort behavior');
	  assert.strictEqual(spy.callCount, 2, 'the "playlistsorted" event triggered');
	});

	QUnit.test('playlist.reverse() works as expected', function (assert) {
	  var player = proxy();
	  var spy = sinon.spy();

	  player.on('playlistsorted', spy);
	  var playlist = factory(player, []);

	  playlist.reverse();
	  assert.deepEqual(playlist(), [], 'playlist did not change because it is empty');
	  assert.strictEqual(spy.callCount, 0, 'the "playlistsorted" event did not trigger');

	  playlist([1, 2, 3, 4]);

	  playlist.reverse();
	  assert.deepEqual(playlist(), [4, 3, 2, 1], 'playlist is reversed');
	  assert.strictEqual(spy.callCount, 1, 'the "playlistsorted" event triggered');
	});

	QUnit.test('playlist.shuffle() works as expected', function (assert) {
	  var player = proxy();
	  var spy = sinon.spy();

	  player.on('playlistsorted', spy);
	  var playlist = factory(player, []);

	  playlist.shuffle();
	  assert.deepEqual(playlist(), [], 'playlist did not change because it is empty');
	  assert.strictEqual(spy.callCount, 0, 'the "playlistsorted" event did not trigger');

	  playlist([1, 2, 3, 4]);

	  playlist.shuffle();

	  var list = playlist();

	  assert.strictEqual(list.length, 4, 'playlist is the correct length');
	  assert.notStrictEqual(list.indexOf(1), -1, '1 is in the list');
	  assert.notStrictEqual(list.indexOf(2), -1, '2 is in the list');
	  assert.notStrictEqual(list.indexOf(3), -1, '3 is in the list');
	  assert.notStrictEqual(list.indexOf(4), -1, '4 is in the list');
	  assert.strictEqual(spy.callCount, 1, 'the "playlistsorted" event triggered');
	});

	QUnit.test('playlist.shuffle({rest: true}) works as expected', function (assert) {
	  var player = proxy();
	  var spy = sinon.spy();

	  player.on('playlistsorted', spy);
	  var playlist = factory(player, [1, 2, 3, 4]);

	  playlist.currentIndex_ = 3;
	  playlist.shuffle({ rest: true });
	  var list = playlist();

	  assert.deepEqual(list, [1, 2, 3, 4], 'playlist is unchanged because the last item is selected');
	  assert.strictEqual(spy.callCount, 0, 'the "playlistsorted" event was not triggered');

	  playlist.currentIndex_ = 2;
	  playlist.shuffle({ rest: true });
	  list = playlist();

	  assert.deepEqual(list, [1, 2, 3, 4], 'playlist is unchanged because the second-to-last item is selected');
	  assert.strictEqual(spy.callCount, 0, 'the "playlistsorted" event was not triggered');

	  playlist.currentIndex_ = 1;
	  playlist.shuffle({ rest: true });
	  list = playlist();

	  assert.strictEqual(list.length, 4, 'playlist is the correct length');
	  assert.strictEqual(list.indexOf(1), 0, '1 is the first item in the list');
	  assert.strictEqual(list.indexOf(2), 1, '2 is the second item in the list');
	  assert.notStrictEqual(list.indexOf(3), -1, '3 is in the list');
	  assert.notStrictEqual(list.indexOf(4), -1, '4 is in the list');
	  assert.strictEqual(spy.callCount, 1, 'the "playlistsorted" event triggered');

	  playlist.currentIndex_ = 0;
	  playlist.shuffle({ rest: true });
	  list = playlist();

	  assert.strictEqual(list.length, 4, 'playlist is the correct length');
	  assert.strictEqual(list.indexOf(1), 0, '1 is the first item in the list');
	  assert.notStrictEqual(list.indexOf(2), -1, '2 is in the list');
	  assert.notStrictEqual(list.indexOf(3), -1, '3 is in the list');
	  assert.notStrictEqual(list.indexOf(4), -1, '4 is in the list');
	  assert.strictEqual(spy.callCount, 2, 'the "playlistsorted" event triggered');

	  playlist.currentIndex_ = -1;
	  playlist.shuffle({ rest: true });
	  list = playlist();

	  assert.strictEqual(list.length, 4, 'playlist is the correct length');
	  assert.notStrictEqual(list.indexOf(1), -1, '1 is in the list');
	  assert.notStrictEqual(list.indexOf(2), -1, '2 is in the list');
	  assert.notStrictEqual(list.indexOf(3), -1, '3 is in the list');
	  assert.notStrictEqual(list.indexOf(4), -1, '4 is in the list');
	  assert.strictEqual(spy.callCount, 3, 'the "playlistsorted" event triggered');
	});

	var version = "4.2.3";

	// Video.js 5/6 cross-compatible.
	var registerPlugin = videojs.registerPlugin || videojs.plugin;

	/**
	 * The video.js playlist plugin. Invokes the playlist-maker to create a
	 * playlist function on the specific player.
	 *
	 * @param {Array} list
	 *        a list of sources
	 *
	 * @param {number} item
	 *        The index to start at
	 */
	var plugin = function plugin(list, item) {
	  factory(this, list, item);
	};

	registerPlugin('playlist', plugin);

	plugin.VERSION = version;

	QUnit.test('the environment is sane', function (assert) {
	  assert.strictEqual(_typeof(Array.isArray), 'function', 'es5 exists');
	  assert.strictEqual(typeof sinon === 'undefined' ? 'undefined' : _typeof(sinon), 'object', 'sinon exists');
	  assert.strictEqual(typeof videojs === 'undefined' ? 'undefined' : _typeof(videojs), 'function', 'videojs exists');
	  assert.strictEqual(typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin), 'function', 'plugin is a function');
	});

	QUnit.test('registers itself with video.js', function (assert) {
	  assert.expect(1);
	  assert.strictEqual(_typeof(videojs.getComponent('Player').prototype.playlist), 'function', 'videojs-playlist plugin was registered');
	});

}(videojs,QUnit,sinon));
